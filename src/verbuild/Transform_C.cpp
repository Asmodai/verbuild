//
// Transform_C.cpp --- C/C++ transform implementation.
//
// Copyright (c) 2017 Paul Ward <asmodai@gmail.com>
//
// Author:     Paul Ward <asmodai@gmail.com>
// Maintainer: Paul Ward <asmodai@gmail.com>
// Created:    24 Nov 2017 04:57:15
//
// {{{ License:
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 3
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, see <http://www.gnu.org/licenses/>.
//
// }}}
// {{{ Commentary:
//
// }}}

/**
 * @file Transform_C.cpp
 * @author Paul Ward
 * @brief C/C++ transform implementation.
 */

#include "Transform_C.hpp"
#include "Console.hpp"
#include "Utils.hpp"
#include "version.hpp"

#include <iostream>
#include <sstream>
#include <regex>
#include <cstdlib>
#include <cstdio>
#include <ctime>

#include <boost/regex.hpp>

using namespace std;

#define VERSION_RE                              \
  "(?:VERSION[_])(\\w+)(?:\\s+)(\\d+)"

#define STRUCT_RE                                       \
  "(?:[{]\\s*)(\\d+)(?:[,]\\s+)(\\d+)(?:[,]\\s+)(\\d+)" \
  "(?:[,]\\s+)(\\d+)(?:[,]\\s+)(\\d+)(?:\\s*[}])"

static
void
write_header_preamble(stringstream &strm)
{
  strm <<
      "/*\n"
      " * ----------------------------------------------------\n"
      " * Automatically generated by VerBuild " << VERSION_STRING << ".\n"
      " * Do not edit by hand.\n"
      " * ----------------------------------------------------\n"
      " */\n\n"
      "#pragma once\n\n"
      "#ifndef __VersionInfo_Header__\n"
      "#define __VersionInfo_Header__\n\n";
}

static
void
write_header_postamble(stringstream &strm)
{
  strm <<
    "#endif // !__VersionInfo_Header__";
}

static
void
write_doxygen_preamble(Config &conf, stringstream &strm)
{
  strm <<
    "/**\n"
    " * @file " << conf.filename << "\n"
    " * @author Verbuild " << VERSION_STRING << "\n"
    " * @brief Provides version information.\n"
    " */\n\n";
}

static
void
write_doxygen_define_comment(Config &conf, stringstream &strm)
{
  string prefix;

  prefix.assign(conf.prefix);
  upcase(prefix);

  strm <<
    "/**\n"
    " * @def " << prefix << "VERSION_MAJOR\n"
    " * @brief Major version number.\n"
    " *\n"
    " * @def " << prefix << "VERSION_MINOR\n"
    " * @brief Minoir version number.\n"
    " *\n"
    " * @def " << prefix << "VERSION_BUILD\n"
    " * @brief Build number.\n"
    " *\n"
    " * @def " << prefix << "VERSION_PPATCH\n"
    " * @brief Patch number.\n"
    " *\n"
    " * @def " << prefix << "VERSION_BASE_YEAR\n"
    " * @brief The year the project was started.\n"
    " *\n"
    " * @def " << prefix << "VERSION_DATE\n"
    " * @brief The date this build was compiled.\n"
    " *\n"
    " * @def " << prefix << "VERSION_TIME\n"
    " * @brief The time this build was compiled.\n"
    " *\n"
    " * @def " << prefix << "VERSION_STRING\n"
    " * @brief String representation of the version.\n"
    " */\n";
}

static
void
write_doxygen_struct_comment(Config &conf, stringstream &strm)
{
  string prefix;

  prefix.assign(conf.prefix);
  upcase(prefix);

  strm <<
    "/**\n"
    " * @Brief Version number structure.\n"
    " *\n"
    " * @var baseYear\n"
    " * @brief The year the project was started.\n"
    " *\n"
    " * @var major\n"
    " * @brief Major version number.\n"
    " *\n"
    " * @var minor\n"
    " * @brief Minor version number.\n"
    " *\n"
    " * @var build\n"
    " * @brief Build number.\n"
    " *\n"
    " * @var patch\n"
    " * @brief Patch number.\n"
    " */\n";
}
      
static
void
write_defines(Config &conf, VersionInfo &vi, stringstream &strm)
{
  string prefix;
  time_t now = time(nullptr);
  char   buf[100] = { 0 };

  if (strftime(buf, sizeof(buf), "%H:%M:%S", localtime(&now)) == 0) {
    perror("strftime");
    exit(EXIT_FAILURE);
  }
  
  prefix.assign(conf.prefix);
  upcase(prefix);  

  strm <<
    "#define " << prefix << "VERSION_MAJOR      " << vi.get_major() << "\n"
    "#define " << prefix << "VERSION_MINOR      " << vi.get_minor() << "\n"
    "#define " << prefix << "VERSION_BUILD      " << vi.get_build() << "\n"
    "#define " << prefix << "VERSION_PATCH      " << vi.get_patch() << "\n\n"
    "#define " << prefix << "VERSION_BASE_YEAR  " << vi.get_base_year() << "\n"
    "#define " << prefix << "VERSION_DATE       \"" << vi.to_date() << "\"\n"
    "#define " << prefix << "VERSION_TIME       \"" << buf << "\"\n"
    "#define " << prefix << "VERSION_STRING     \"" << vi.to_string() << "\"\n\n";
}

static
void
write_struct(Config       &conf,
             VersionInfo  &vi,
             stringstream &strm,
             bool         use_preprocessor = false)
{
  strm <<
    "static struct " << conf.prefix << "VersionNumber_s {\n"
    "    int baseYear;\n"
    "    int major;\n"
    "    int build;\n"
    "    int patch;\n"
    "} " << conf.prefix << "VersionNumber = {\n";

  switch (use_preprocessor) {
    case true: {
        string prefix;
        prefix.assign(conf.prefix);
        strm
          << "    " << prefix << "VERSION_BASE_YEAR" << ",\n"
          << "    " << prefix << "VERSION_MAJOR" << ",\n"
          << "    " << prefix << "VERSION_MINOR" << ",\n"
          << "    " << prefix << "VERSION_BUILD" << ",\n"
          << "    " << prefix << "VERSION_PATCH" << "\n";
      }
      break;

    case false:
      strm
        << "    " << vi.get_base_year() << ",\n"
        << "    " << vi.get_major() << ",\n"
        << "    " << vi.get_minor() << ",\n"
        << "    " << vi.get_build() << ",\n"
        << "    " << vi.get_patch() << "\n";
      break;
  }
   strm << "};\n\n";
}

bool
CTransform::read_impl(VersionInfo &vi, std::string &buffer)
{
  DSAY(DEBUG_MEDIUM, "Reading C file");

  if (buffer.length() > 0) {
    boost::regex rgx;

    rgx.set_expression("\\s*\n\\s*");
    boost::regex_replace(buffer.begin(),
      buffer.begin(),
      buffer.end(),
      rgx,
      " ");

    DSAY(DEBUG_MEDIUM, "Trying structure regex.");
    {
      boost::smatch matches;
      rgx.set_expression(STRUCT_RE);
      if (boost::regex_search(buffer, matches, rgx)) {
        if (matches.size() != 6) {
          return false;
        }

        DSAY(DEBUG_HIGH, "Reading version info.");
        vi.set_base_year(safe_stoi(matches[1]));
        vi.set_major(safe_stoi(matches[2]));
        vi.set_minor(safe_stoi(matches[3]));
        vi.set_build(safe_stoi(matches[4]));
        vi.set_patch(safe_stoi(matches[5]));

        return true;
      }
    }
    

    DSAY(DEBUG_MEDIUM, "Trying define regex.");
    {
      bool ok = false;

      rgx.set_expression(VERSION_RE);
      boost::regex_token_iterator<std::string::iterator> it{
        buffer.begin(),
        buffer.end(),
        rgx,
        {1,2}
      };
      boost::regex_token_iterator<std::string::iterator> end;

      while (it != end) {
        if (*it == "MAJOR") {
          *it++;
          DSAY(DEBUG_HIGH, "Reading major:", *it);
          vi.set_major(safe_stoi(*it));
          ok = true;
        } else if (*it == "MINOR") {
          *it++;
          DSAY(DEBUG_HIGH, "Reading minor:", *it);
          vi.set_minor(safe_stoi(*it));
          ok = true;
        } else if (*it == "BUILD") {
          *it++;
          DSAY(DEBUG_HIGH, "Reading build:", *it);
          vi.set_build(safe_stoi(*it));
          ok = true;
        } else if (*it == "PATCH") {
          *it++;
          ok = true;
          DSAY(DEBUG_HIGH, "Reading patch:", *it);
          vi.set_patch(safe_stoi(*it));
        } else if (*it == "BASE_YEAR") {
          *it++;
          DSAY(DEBUG_HIGH, "Reading base year:", *it);
          vi.set_base_year(safe_stoi(*it));
          ok = true;
        } else {
          ok = false;
        }

        *it++;
      }

      return ok;
    }
  }

  return false;
}

#define IS_GROUP(__p)   ((conf_.groups & __p) == __p)
bool
CTransform::write_impl(VersionInfo &vi, stringstream &strm)
{
  bool with_doxygen = IS_GROUP(OutputGroups::Doxygen);
  bool with_basic   = IS_GROUP(OutputGroups::Basic);
  bool with_struct  = IS_GROUP(OutputGroups::Struct);

  write_header_preamble(strm);
  if (with_doxygen) {
    write_doxygen_preamble(conf_, strm);
  }

  if (with_basic) {
    if (with_doxygen) {
      write_doxygen_define_comment(conf_, strm);
    }
    
    write_defines(conf_, vi, strm);
  }

  if (with_struct) {
    if (with_doxygen) {
      write_doxygen_struct_comment(conf_, strm);
    }

    write_struct(conf_, vi, strm, with_basic);
  }

  write_header_postamble(strm);
  strm << endl;

  return true;
}
#undef IS_GROUP

// Transform_C.cpp ends here.
