//
// Transform_C.cpp --- C/C++ transform implementation.
//
// Copyright (c) 2017 Paul Ward <asmodai@gmail.com>
//
// Author:     Paul Ward <asmodai@gmail.com>
// Maintainer: Paul Ward <asmodai@gmail.com>
// Created:    24 Nov 2017 04:57:15
//
// {{{ License:
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 3
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, see <http://www.gnu.org/licenses/>.
//
// }}}
// {{{ Commentary:
//
// }}}

/**
 * @file Transform_C.cpp
 * @author Paul Ward
 * @brief C/C++ transform implementation.
 */

#include "Transform_C.hpp"
#include "Console.hpp"
#include "Utils.hpp"
#include "version.hpp"

#include <iostream>
#include <sstream>
#include <regex>

#include <boost/regex.hpp>

using namespace std;

#define VERSION_RE                              \
  "(?:VERSION[_])(\\w+)(?:\\s+)(\\d+)"

#define STRUCT_RE                                       \
  "(?:[{]\\s*)(\\d+)(?:[,]\\s+)(\\d+)(?:[,]\\s+)(\\d+)" \
  "(?:[,]\\s+)(\\d+)(?:[,]\\s+)(\\d+)(?:\\s*[}])"

static
void
write_header_preamble(stringstream &strm)
{
  strm <<
      "/*\n"
      " * ----------------------------------------------------\n"
      " * Automatically generated by VerBuild " << VERSION_STRING << ".\n"
      " * Do not edit by hand.\n"
      " * ----------------------------------------------------\n"
      " */\n\n"
      "#pragma once\n\n"
      "#ifndef __VersionInfo_Header__\n"
      "#define __VersionInfo_Header__\n\n";
}

static
void
write_header_postamble(stringstream &strm)
{
  // Doesn't need a trailing newline, that gets written by write_impl.
  strm <<
    "#endif // !__VersionInfo_Header__";
}
      
static
void
write_defines(stringstream &strm, VersionInfo &vi)
{
  strm <<
    "#define " << "" << "VERSION_MAJOR      " << vi.get_major() << "\n"
    "#define " << "" << "VERSION_MINOR      " << vi.get_minor() << "\n"
    "#define " << "" << "VERSION_BUILD      " << vi.get_build() << "\n"
    "#define " << "" << "VERSION_PATCH      " << vi.get_patch() << "\n\n"
    "#define " << "" << "VERSION_BASE_YEAR  " << vi.get_base_year() << "\n"
    "#define " << "" << "VERSION_DATE       " << "\"Nope\"" << "\n"
    "#define " << "" << "VERSION_TIME       " << "\"Nope\"" << "\n"
    "#define " << "" << "VERSION_STRING     " << "\"Derp\"" << "\n\n";
}



bool
CTransform::read_impl(VersionInfo &vi, std::string &buffer)
{
  DSAY(DEBUG_MEDIUM, "Reading C file");

  if (buffer.length() > 0) {
    boost::regex  rgx;

    rgx.set_expression("\\s*\n\\s*");
    boost::regex_replace(buffer.begin(),
      buffer.begin(),
      buffer.end(),
      rgx,
      " ");

    DSAY(DEBUG_MEDIUM, "Trying structure regex.");
    {
      boost::smatch matches;
      rgx.set_expression(STRUCT_RE);
      if (boost::regex_search(buffer, matches, rgx)) {
        if (matches.size() != 6) {
          return false;
        }

        vi.set_base_year(safe_stoi(matches[1]));
        vi.set_major(safe_stoi(matches[2]));
        vi.set_minor(safe_stoi(matches[3]));
        vi.set_build(safe_stoi(matches[4]));
        vi.set_patch(safe_stoi(matches[5]));

        return true;
      }
    }
    

    DSAY(DEBUG_MEDIUM, "Trying define regex.");
    {
      bool ok = false;

      rgx.set_expression(VERSION_RE);
      boost::regex_token_iterator<std::string::iterator> it{
        buffer.begin(),
        buffer.end(),
        rgx,
        {1,2}
      };
      boost::regex_token_iterator<std::string::iterator> end;

      while (it != end) {
        if (*it == "MAJOR") {
          *it++;
          vi.set_major(safe_stoi(*it));
          ok = true;
        } else if (*it == "MINOR") {
          *it++;
          vi.set_minor(safe_stoi(*it));
          ok = true;
        } else if (*it == "BUILD") {
          *it++;
          vi.set_build(safe_stoi(*it));
          ok = true;
        } else if (*it == "PATCH") {
          *it++;
          ok = true;
          vi.set_patch(safe_stoi(*it));
        } else if (*it == "BASE_YEAR") {
          *it++;
          vi.set_base_year(safe_stoi(*it));
          ok = true;
        } else {
          ok = false;
        }

        *it++;
      }

      return ok;
    }
  }

  return false;
}

bool
CTransform::write_impl(VersionInfo &vi, std::string &)
{
  stringstream ss;

  write_header_preamble(ss);
  write_defines(ss, vi);
  write_header_postamble(ss);

  cout << ss.str() << endl;

  return true;
}

// Transform_C.cpp ends here.
